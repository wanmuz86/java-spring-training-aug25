package com.example.kafka_streams_demo;

import java.util.Arrays;
import java.util.Properties;

import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.streams.KafkaStreams;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.StreamsConfig;
import org.apache.kafka.streams.kstream.KStream;
import org.apache.kafka.streams.kstream.KTable;
import org.apache.kafka.streams.kstream.Materialized;
import org.apache.kafka.streams.kstream.Produced;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class KafkaStreamsConfig {

    @Bean
    public KafkaStreams kafkaStreams() {
        // Configuration to setup the streams
        Properties props = new Properties();
        props.put(StreamsConfig.APPLICATION_ID_CONFIG, "my-streams-app");
        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, org.apache.kafka.common.serialization.Serdes.String().getClass().getName());
        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, org.apache.kafka.common.serialization.Serdes.String().getClass().getName());

        // Create the Stream
        StreamsBuilder builder = new StreamsBuilder();
        // Receive the "message" from producer as a Stream
        KStream<String, String> sourceStream = builder.stream("input-topic");

        // Scenario 1 : Example with uppercase
        // Transform the stream by converting values to uppercase
    //    KStream<String, String> processedStream = sourceStream.mapValues(value->value.toUpperCase());

        // Write the processed stream to the output topic
    //    processedStream.to("output-topic", Produced.with(org.apache.kafka.common.serialization.Serdes.String(), org.apache.kafka.common.serialization.Serdes.String()));

      // Scenario 2 : Calculate the number of words, and show the xx popular  
        // flatMapValues -> For each stream, for each value
        // all the word will be lowercase and will be split by symbol / spac -> return as array
        // Hello World!
        // Hello JOHN
        // GOODBYE world!
        // ["hello","world", "hello", "john", "goodbye","world"]
      
        KStream<String, String>  wordsStream = sourceStream.flatMapValues(value->
        Arrays.asList(value.toLowerCase().split("\\W+")));
        
        // For each words, i will group by word, and I will count it
        // ["hello" ->2, "world" ->2, "john"->1, "gooodbye"-1>]
        // Materialized as , means store in temporary table , KTable
        KTable<String, Long> wordCounts = wordsStream
        		.groupBy((key,word)->word)
        		.count(Materialized.as("word-count-store"));;
        
        // Create a message
        // Send it to word-counts-topic
        // And the message is of format String, Long
        wordCounts.toStream().to("word-counts-topic", Produced.with(Serdes.String(),
        Serdes.Long()));
       
        // Build the Kafka Streams instance
        KafkaStreams streams = new KafkaStreams(builder.build(), props);

        // Start the stream
        streams.start();

        // Add shutdown hook to close streams on application shutdown
        Runtime.getRuntime().addShutdownHook(new Thread(streams::close));

        return streams;
    }
}